/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class AppTest {
    private static final Logger LOGGER = LoggerFactory.getLogger(AppTest.class);

    static String csvSafeString(String str) {
        if (str != null) {
            return "\"" + str.replaceAll("\"", "\"\"") + "\"";
        } else {
            return "";
        }
    }

    @Test
    public void testCreateUnmappableFile() {
        File file = new File("\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D.c");

    }

    @Test
    public void name() throws Exception {
        LOGGER.debug("Debug logger");
        assertTrue(true);
    }

    @Test
    public void testCsvSafeString() {
        LOGGER.error("ERROR STRING");
        assertTrue(true);
        //assertEquals("\"string with, and \"\"quotes\"\"\"", csvSafeString("string with, and \"quotes\""));
        //assertEquals("123", csvSafeString("test_match_returnExpectedMatch_whenPatternAndTextProvided[match should return true when pattern \"*a\\Qb*\" and text \"a\\Qb\" provided]"));
    }

    @Test
    public void testSomeChineseOutput() {
        // FIRE-12594
        LOGGER.error("Chinese output: \uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D\uD843\uDF2D");
    }

    private static String oldCSVOutputFunction(CSVFormat format, String strVal, Integer intVal) {
        return String.format("\"%s\",%d%n", strVal, intVal);
    }

    private static String newCSVOutputFunction(CSVFormat format, String strVal, Integer intVal) throws IOException {
        StringBuilder stringBuilder = new StringBuilder();
        format.print(stringBuilder).printRecord(strVal, intVal);
        return stringBuilder.toString();
    }

    @Test
    public void testProperCSVEscaping() throws Exception {
        CSVFormat format = CSVFormat.DEFAULT;
        ImmutablePair<String, Integer>[] testCases = new ImmutablePair[] {
                new ImmutablePair("STR", 1),
                new ImmutablePair("\"STR\"", 2)
        };
        String result = Arrays.stream(testCases)
                .map(pair -> {
                    try {
                        return newCSVOutputFunction(format, pair.getLeft(), pair.getRight());
                    } catch (IOException e) {
                        e.printStackTrace();
                        return "";
                    }
                })
                .collect(Collectors.joining());
        try (CSVParser parser = new CSVParser(new StringReader(result), format)) {
            List<CSVRecord> recordList = parser.getRecords();
            assertEquals(testCases.length, recordList.size());
            for (int i = 0; i < testCases.length; i++) {
                CSVRecord record = recordList.get(i);
                assertEquals(testCases[i].getLeft(), record.get(0));
                assertEquals(String.valueOf(testCases[i].getRight()), record.get(1));
            }
        }
    }
}
